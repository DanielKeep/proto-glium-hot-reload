
Glium Hot Reload Prototype
==========================

The root package is the driver program.  `sandbox_abi` is where all types that are shared between the driver and hot reloaded components need to live.  `sandbox_render` is a hot reloadable component.  `sandbox` and `sandbox_render` cannot refer directly to one another, and `sandbox_abi` cannot have any references out to other `sandbox*` crates.

How It's Supposed To Work
-------------------------

First, you need to make sure that both `sandbox` and `sandbox_render` have the same versions of all dependencies in their `Cargo.lock` files (hence why they're checked in).

You can then compile and run `sandbox` with `cargo run`.  Although `sandbox` doesn't link directly to `sandbox_render`, it includes it as a dependency specifically to trigger a build and place it in `target/deps`.  The actual name is *irrelevant* since we'll be loading it dynamically by prefix anyway.

On startup, `sandbox` will locate and load the `sandbox_render*.dll` with the newest timestamp it can find in `target/deps` (which should be the one Cargo just built).  It constructs the actual `Renderer` component by calling the library's `module_factory` function.

You can now go make a change to `sandbox_render`, rebuild it with `cargo build` (*i.e.* rebuild in the `sandbox_render` package, not the `sandbox` package).  You can then copy the resulting `sandbox_render*.dll` into `sandbox/target/deps` under a new name.

At this point, switch back to the render window and press `r`.  This will cause the driver to freeze the existing render component, re-locate the newest `sandbox_render*.dll`, load it, and call `module_factory` to get a new object instance.  With that done, it resumes the main loop.

**Aside**: the purpose of `frozen` is to give components a way to pass arbitrary data *forward* to the next instance.  The intent here is to use a `Vec<u8>` generated by something like `bincode` for plain-old-data fields, and other strongly-typed values for things with complex behaviour.  The purpose of `deps` is to get around the fact that Glium **really hates** being initialised more than once.

What Actually Happens
---------------------

A key part of this is being able to pass a `glium::Display` from the driver to the renderer.  I want to avoid doing this directly, because I want to try abstracting all of this into a general-purpose hot reload library at some point.  Hence, the `TypeMap` for dependencies.

*Theoretically*, the type ID of `sandbox_abi::DisplayKey` should stay the same because `sandbox_abi` is **NOT** being modified between compiling `sandbox` and subsequent recompiles of `sandbox_render`.  And, since it's an external (to the `sandbox*` family) type, there shouldn't be any binary compatibility issues.

But that's not what happens.  The `TypeId` of `DisplayKey` is different, based on what's printed out from `sandbox::main` and `sandbox_render::GliumRenderer::new`.

**Aside**: I thought about trying to make `sandbox_abi` a dynamic library, but that just causes mountains of linking errors... in `sandbox_render` when it's trying to find symbols in `glium`.  I have... *no* idea why.
